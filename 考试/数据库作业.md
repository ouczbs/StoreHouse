



# **第一章 绪论** 

<div align='center' ><font size='70'><b>第 1 周第 1 次课作业  </b></font></div>

**课后习题 1、4、5、7、8、9** 

**1.试述数据、数据库、数据库系统、数据库管理系统的概念。** 

​	**数据：**数据是描述事物的描述符号，是数据库的基本储存单元。

​	**数据库：**数据库是长期储存在计算机内，有组织的可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述、储存，具有较小的冗余度、较高的数据独立性、易扩展性，并可为各种用户共享。

​	**数据库系统：**数据库系统是在计算机系统中引入数据库后的系统。由数据库、数据库管理系统、数据库应用系统、数据库管理员组成。 

​	**数据库管理系统：**数据库系统是管理数据库，完成对数据库的一切操作，包括定义、查询、更新以及各种控制的软件系统，是用户和数据库的桥梁，是数据库系统的核心。



**4.举出适合用文件系统而不是数据库系统的例子，以及适合用数据库系统的应用例 子。**

​	**适合用于文件系统：**应用程序的配置数据，放在文件中容易修改和阅读，应用程序的临时数据。

​	**适合于数据库系统：**目前，几乎所有企业或部分的信息系统都以数据库系统为基础，都使用数据库。包括学校的学生管理系统，工厂的信息系统等。



**5.试述数据库系统的特点。** 

1. 数据结构化

2. 数据的共享性高，冗余度低，易扩充

3. 数据独立性高

4. 数据由数据库管理系统统一管理和控制



**7.什么是概念模型？试述概念模型的作用。** 

​	**概念模型：**概念模型是现实世界到计算机世界的一个中间层次，是按用户的观点来对数据和信息建模，用于数据库设计。

​	**概念模型作用：**概念模型用于信息世界的建模，是现实世界到信息世界的一层抽象。概念模型是数据库设计人员进行数据库设计的有力工具。概念模型是数据库设计人员和用户进行交流的语言



**8.定义并解释概念模型中以下术语：实体，实体型，实体集，实体之间的联系。** 

​	**实体：**客观存在并可相互区别的事物称为实体，可指人或实际的东西，也可指概念性的东西。 

​	**实体型：**用实体名及其属性名集合来抽象和刻画同类实体称为实体型 

​	**实体集：**同一类型实体的集合成为实体集 

​	**联系：**现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系。实体内部的联系通常是指组成实体的各属性之间的系实体之间的联系通常是指不同实体集之间的联系。 



**9.试述数据模型的概念、数据模型的作用和数据模型的三个要素。**

​	**数据模型：**是数据库中用来实现对现实世界进行抽象的工具，是数据库中用于提供信息表示和操作手段的形式架构。

​	**数据模型作用：** 是数据库系统的基础，任何 一个 DBMS 都以某一个数据模型为基础， 或者说支持某一个数据模型。

​	**数据模型三要素：**数据结构、数据操作、完整性约束



# 第二章 关系数据库

<div align='center' ><font size='70'><b>第 2 章 关系数据库 作业  </b></font></div>

**课本第 70 页，习题 1、3、5、6、7、8** 



**1.试述关系的三个组成部分。** 

关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成



**3.定义并理解下列术语：** 

**（1）域，笛卡尔积，关系，元组，属性** 

​	**域**： 一组具有相同的数据类型的值的集合。

​	**笛卡尔积**： 域上的一种集合运算，给定一组域$D_1，D_2，…，D_n$，允许其中某些域是相同的。则$D_1，D_2，…，D_n$的笛卡尔积为：

​		$D_1 \times D_2 \times… \times D_n ＝ \{(d_1，d_2，…，d_n) \mid d_i \in D_i, i＝1,2,…,n\}$ 是所有域所有取值的一个组合。

​	**关系**： $D_1 \times D_2 \times… \times D_n $的 子集 叫作在域$D_1，D_2，…，D_n$上的关系，表示为$R(D_1，D_2，…，D_n)$， R：关系名，n：关系的目或度。

​	**元组**： 笛卡尔积中每一个元素$(d_1，d_2，…，d_n)$叫作一个n元组或简称元组。

​	**属性**： 关系对应一个二维表，表的列对应一个域，由于域可以相同，所以对每列起名字，则称为属性，n目关系则有n个属性。

​	**联系和区别**： 笛卡尔积是在域上进行运算的，元组是笛卡尔积中的元素，关系是笛卡尔积的子集，属性是关系对应二维表的列。

**（2）主码，候选码，外码** 

​	**主码:** 一个关系有多个候选码，则选定其中一个为主码。一个关系只能有一个主码。

​	**候选码:** 若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码。

​	**外码:**设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是R的外码。 基本关系R称为参照关系，基本关系S称为被参照关系。

**（3）关系模式，关系，关系数据库** 

​	**关系模式:** 关系模式是对关系的描述，可以形式化地表示为R（U，D，DOM，F）。R为关系名，U组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映象的集合，F为属性间数据的依赖关系的集合。简记为R（U）。

​	**关系:** 关系模式在某一时刻的状态或内容。

​	**关系数据库:** 在一个给定的应用领域中，所有关系的集合构成一个关系数据库。关系数据库的型是关系数据库的模式，是对关系数据库的描述。关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库。

​	**联系和区别**： 关系模式是对关系的描述。关系数据库是关系的集合。
 关系模式是静态稳定的，关系是动态，随时间不断变化的，因为关系操作总是更新着数据。

**5.试述关系模型的完整性规则。在参照完整性中，什么情况下外部码属性的值 可以为空？** 

​	**实体完整性规则：**若属性 A 是基本关系 R 的主属性，则属性 A 不能取空值。 

​	**参照完整性规则：**若属性（或属性组）F 是基本关系 R 的外码，它与基本关系 S 的主码 K 相对应（基本关系 R 和 S 不一定是不同的关系），则对于 R 中每个元组在 F 上的值必须为： 

​		（1）或者取空值（F 的每个属性值均为空值） 

​		（2）或者等于 S 中某个元组的主码值 

​	**用户定义的完整性:** 是针对某一具体关系数据库的约束条件。它反映了某一具 体应用所涉及的数据必须满足的语义要求。

   在参照完整性中，如果外码属性不是其所在关系的主属性，当外码属性的值没有或无意义可以取空值。



**6.见课本第 70-71 页** 

​	(1) $\Pi_{SNO}(\sigma_{JNO = 'J1'}(SPJ)) $

​	(2) $\Pi_{SNO}(\sigma_{JNO = 'J1' \wedge PNO = 'P1'}(SPJ)) $

​	(3) $\Pi_{SNO}(\sigma_{COLOR = '红'}(P) \Join \sigma_{JNO = 'J1'}(SPJ)) $

​	(4) $\Pi_{JNO}(J) - \Pi_{JNO}(\Pi_{JNO,PNO}(\sigma_{COLOR = '红'}(P) \Join \sigma_{CITY = '天津'}(J)) \Join SPJ) $

​	(5) $\Pi_{PNO,JNO}(SPJ) \div \Pi_{PNO}(\sigma_{JNO = 'S1'}(SPJ)) $



**7.试述等值连接与自然连接的区别和联系。**  

他们是连接运算中两种最为重要、也是最为常用的连接。 

**自然连接：**是一种特殊的等值连接，它要求两个关系中进行比较的分量，即连 

接属性必须是相同的属性组，并且在结果中把重复的属性列去掉



**8.关系代数的基本运算有哪些？如何用这些基本运算来表述其他运算？**

关系代数的基本运算有5种，分别为**并**、**差**、**笛卡尔积**、**投影** 和 **选择**。

其他3种运算，即**交**、**连接**和**除**，均可以用这5种基本运算来表达。

交运算：$R \cap S = R - (R - S) $
连接运算：$R \underset{A \theta B }\Join S = \sigma_{A \theta B}(R \times S)$
除运算： $R(X,Y) \div S(Y,Z) = \Pi_X(R) - \Pi_X(\Pi_X(R) \Join \Pi_Y(S) - R) $





# 第三章 关系数据库标志语言SQL

<div align='center' ><font size='70'><b>第3章 关系数据库标准语言SQL 作业  </b></font></div>

**课本第130页，习题1、2、3、4、5、6、7、8、9**

**1.试述SQL的特点。**

1. 综合统一: 一种操作一种操作符,sql 语言集定义、查询、操作、控制于一体

2. 高度非过程化:  只要提出做什么，而不需指明怎么做

3. 面向集合的操作方式: 操作的对象和结果都可以是集合

4. 以同一种语法结构提供多种使用方式: 即是独立语言,又是嵌入语言

5. 语言简洁，易学易用 9个动词完成核心功能

   

**2.说明在DROPTABLE时，RESTRICT和CASCADE的区别。**

CASCADE(级联): 在删除基本表的同时，相关的依赖对象会被一并删除。 

RESTRICT(限制): 当被删除的表还涉及到其他依赖对象时，拒绝删除。



**3.有两个关系S(A,B,C,D)和T(C,D,E,F),写出与查询等价的SQL表达式。（详见课本）**

（1）$ \sigma_{A = 10}(S)$ = ` select * from S where A = 10;`

（2）$ \Pi_{A,B}(S)$ = ` select distinct A,B from S;`

（3）$S \Join T$ = ` select S.*,E,F from S,T where S.C = T.C and S.D = T.D;`

（4）$ S \underset {S.C = T.C} \Join T$ = ` select * from S,T where S.C = T.C;`

（5）$S \underset {A < E} \Join T$ = ` select * from S,T where A = E;`

  (6) $\Pi_{C,D}(S) \times  T$ = `select * from (select distinct C,D from S),T;`



**4.用SQL语句建立第2章习题6中的4个表；针对建立的4个表用SQL语言完成第2 章习题6中的查询。**

**建表：**

```sql
create table S(
	SNO CHAR(10) PRIMARY KEY,
    SNAME CHAR(10),
    STATUS SMALLINT,
    CITY CHAR(10)
);
insert SC values ('S1' , 'C1' , 60 )
			   ,('S1' , 'C2' , 70 )
			   ,('S1' , 'C3' , 80 )
			   ,('S1' , 'C4' , 85)
			   ,('S1' , 'C1' , 50)
			   ,('S2' , 'C2' , 80 )
			   ,('S2' , 'C5' , 90 )
			   ,('S2' , 'C4' , 86)
			   ,('S3' , 'C3' , 55)
			   ,('S3' , 'C4' , 84)
			   ,('S4' , 'C5' , 53)
			   ,('S5' , 'C4' , 83)
			   ,('S5' , 'C2' , 72)
			   ;
			   
insert S values ('S1' , '精益' , 20 , '天津')
			   ,('S2' , '盛锡' , 10 , '北京')
			   ,('S3' , '东方红' , 30 , '北京')
			   ,('S4' , '丰泰盛' , 20 , '天津')
			   ,('S5' , '为民' , 30 , '上海')
			   ;
create table P(
	PNO CHAR(10) PRIMARY KEY,
    PNAME CHAR(10),
    COLOR CHAR(10),
    WEIGHT SMALLINT
);
insert P values ('P1' , '螺母' , '红' , 12)
			   ,('P2' , '螺栓' , '绿' , 17)
			   ,('P3' , '螺丝刀' , '蓝' , 14)
			   ,('P4' , '螺丝刀' , '红' , 14)
			   ,('P5' , '凸轮' , '蓝' , 40)
			   ,('P6' , '齿轮' , '红' , 30)
			   ;
create table J(
	JNO CHAR(10) PRIMARY KEY,
    JNAME CHAR(10),
    CITY CHAR(10)
);
insert J values ('J1' , '三建'  , '北京')
			   ,('J2' , '一汽'  , '长春')
			   ,('J3' , '弹簧厂'  , '天津')
			   ,('J4' , '造船厂'  , '天津')
			   ,('J5' , '机车厂'  , '唐山')
			   ,('J6' , '无线电厂'  , '常州')
			   ,('J7' , '半导体厂'  , '南京')
			   ;
create table SPJ(
	SNO CHAR(10),
    PNO CHAR(10),
    JNO CHAR(10),
    QTY SMALLINT,
    PRIMARY KEY (SNO,PNO,JNO),
    FOREIGN KEY (SNO) REFERENCES S(SNO),
    FOREIGN KEY (PNO) REFERENCES P(PNO),
    FOREIGN KEY (JNO) REFERENCES J(JNO)
);
insert SPJ values ('S1' , 'P1' , 'J1', 200)
			     ,('S1' , 'P1' , 'J3', 100)
			     ,('S1' , 'P1' , 'J4', 700)
			     ,('S1' , 'P2' , 'J2', 100)
			     
			     ,('S2' , 'P3' , 'J1', 400)
			     ,('S2' , 'P3' , 'J2', 200)
			     ,('S2' , 'P3' , 'J4', 500)
			     ,('S2' , 'P3' , 'J5', 400)
			     ,('S2' , 'P5' , 'J1', 400)
			     ,('S2' , 'P5' , 'J2', 100)
			     
			     ,('S3' , 'P1' , 'J1', 200)
			     ,('S3' , 'P3' , 'J1', 200)
			     ,('S4' , 'P5' , 'J1', 100)
			     ,('S4' , 'P6' , 'J3', 300)
			     ,('S4' , 'P6' , 'J4', 200)
			     
			     ,('S5' , 'P2' , 'J4', 100)
			     ,('S5' , 'P3' , 'J1', 200)
			     ,('S5' , 'P6' , 'J2', 200)
			     ,('S5' , 'P6' , 'J4', 500)
			     ;
```

**查询：**

```sql
#(1) 求供应工程J1零件的供应商号码SNO;
SELECT SNO FROM SPJ WHERE JNO = 'J1';

#(2) 求供应工程J1零件P1的供应商号码SNO;
SELECT SNO FROM SPJ WHERE JNO = 'J1' AND PNO = 'P1';

#(3) 求供应工程J1零件为红色的供应商号码SNO;
SELECT SNO FROM SPJ,P WHERE SPJ.JNO = 'J1' AND P.PNO = SPJ.PNO AND P.COLOR = '红';

#(4) 求没有使用天津供应商生产的红色零件的工程号JNO;
SELECT JNO FROM J WHERE JNO NOT IN(
    SELECT JNO FROM S,P,SPJ WHERE S.CITY = '天津' AND P.COLOR = '红' AND S.SNO = SPJ.SNO AND P.PNO = SPJ.PNO);

#(5) 求至少使用了供应商S1所供应的全部零件的工程号JNO;
SELECT JNO FROM J WHERE NOT EXISTS (
    	SELECT PNO FROM SPJ WHERE SNO = 'S1' AND NOT EXISTS (
            SELECT PNO FROM SPJ AS SPJ2 WHERE SPJ2.PNO = SPJ.PNO AND SPJ2.JNO = J.JNO AND SNO = 'S1'));
```



**5.针对习题3中的4个表，试用SQL语言完成各项操作。（详见课本）**

```sql
#(1) 找出所有供应商的姓名和所在城市;
SELECT SNAME,CITY FROM S;

#(2) 找出所有零件的名称、颜色、重量;
SELECT PNAME,COLOR,WEIGHT FROM P;

#(3) 找出使用供应商S1所供应零件的工程号码;
SELECT JNO FROM SPJ WHERE SNO = 'S1';

#(4) 找出工程项目J2使用的各种零件的名称及其数量;
SELECT PNAME,QITY FROM SPJ,P WHERE JNO = 'J2' AND SPJ.PNO = P.PNO;

#(5)找出上海厂商供应的所有零件号码。
SELECT PNO FROM SPJ,S WHERE SPJ.SNO = S.SNO AND CITY = '上海';

#(6)找出使用上海产的零件的工程名称。
SELECT DISTINCT JNO FROM SPJ WHERE SNO IN (SELECT SNO FROM S WHERE CITY = '上海');

#(7)找出没有使用天津产的零件的工程号码。.
SELECT JNO FROM J WHERE NOT EXISTS (
	SELECT * FROM SPJ,S WHERE SPJ.JNO = J.JNO AND S.CITY = '天津' AND S.SNO = SPJ.SNO);

#(8)把全部红色零件的颜色改成蓝色。
UPDATE P SET COLOR = '蓝' WHERE COLOR = '红';

#(9)由S5供给J4的零件P6改为由S3供应，请作必要的修改。
UPDATE SPJ SET SNO = 'S3' WHERE SNO = 'S5' AND PNO = 'P6';

#(10)从供应商关系中删除S2的记录，并从供应情况关系中删除相应的记录。
DELETE FROM SPJ WHERE SNO ='S2';
DELETE FROM S WHERE SNO = 'S2';


#(11)请将(S2, J6，P4，200) 插入供应情况关系。
INSERT INTO SPJ VALUES('S2' , 'J6', 'P4' , 200);
```



**6.什么是基本表？什么是视图？两者的区别和联系是什么？**

**基本表:** 基本表是本身独立存在的表，在 SQL 中一个关系就对应一个基本表。 

**视图：**视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表。即 数据库中只存放视图的定义而不存放视图对应的数据,这些数据仍存放在导出视图的基本表中。 

视图在概念上与基本表等同，用户可以如同基本表那样使用视图,可以在视图上再定义视图。 



**7.试述视图的优点。**

1. 视图能够简化用户的操作。 

2. 视图使用户能以多种角度看待同一数据。 

3. 视图对重构数据库提供了一定程度的逻辑独立性。 

4. 视图能够对机密数据提供安全保护



**8.哪类视图是可以更新的，哪类视图是不可更新的？各举一例说明。**

基本表的行列子集视图一般是可更新的。

若视图的属性来自聚集函数、表达式，则该视图肯定是不可以更新的。



9.请为三建工程项目建立一个供应情况的视图，包括供应商代码(SNO)、零件代码 (PNO)、供应数量(QTY)O,针对该视图完成下列查询：

①找出三建工程项目使用的各种零件代码及其数量。

②找出供应商S1供应三建工程的情况。

```sql
#创建视图
CREATE VIEW SP_SANJIAN
	AS SELECT SNO,PNO,QTY FROM SPJ,J WHERE SPJ.JNO = J.JNO AND J.JNAME = '三建';
	
#1.找出三建工程项目使用的各种零件代码及其数量。
SELECT DISTINCT PNO,QTY FROM SP_SANJIAN;

#2.找出供应商S1供应三建工程的情况。
SELECT DISTINCT PNO,QTY FROM SP_SANJIAN WHERE SNO = 'S1';
```



# **第四章 数据库安全性 作业** 

<div align='center' ><font size='70'><b>第四章 数据库安全性 作业  </b></font></div>

**课后习题 1、2、4、5、6** 

**1.什么是数据库的安全性？** 

​	数据库的安全性是指保护数据库，以防止不合法使用所造成的数据泄露、更改或破坏。数据库系统中由于大量数据集中存放，共享，从而使安全性问题更加突出。系统安全保护措施是否有效是数据库系统的主要技术指标之一。 



**2.举例说明对数据库安全性产生威胁的因素。** 

​	非授权用户对数据库的恶意存取和破坏:黑客或非法用户通过非法途径窃取用户名和口令，窃取、修改甚至破坏用户数据。数据库中重要或敏感数据被泄露：千方百计盗窃数据库中的重要数据，导致机密数据暴露。



**4.试述实现数据库安全性控制的常用方法和技术。** 

**（1）用户身份鉴别**：该方法由系统提供一定的方式让用户标识自己的名字或身 

份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供系统的使用权。 

**（2） 存取控制（自主，强制）**：通过用户权限定义和合法权检查确保只有合法 

权限的用户访问数据库，所有未被授权的人员无法存取数据。 

**（3）视图机制**：为不同的用户定义视图，通过视图机制把要保密的数据对无权 

存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。 

**（4）审计：**建立审计日志，把用户对数据库的所有操作自动记录下来放入审计 

日志中，DBA 可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件， 

找出非法存取数据的人、时间和内容等。 

**（5）数据加密**：对存取和传输的数据进行加密处理，从而使得不知道解密算法 

的人无法获知数据的内容。 



**5.什么是数据库中的自助存取控制方法和强制存取控制方法？** 

**（1）自主存取控制方法：**定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。 用户可以将自己拥有的存取权限“自主”地授予别人，即用户具有一定的“自主”权。 

**（2）强制存取控制方法：**每一个数据对象被（强制地）标以一定的密级。每一个用户也被强制地授予某一个级别的许可证。系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象。 



**6.对下列两个关系模式：** 

学生（学号，姓名 ，年龄，性别，家庭住址，班级号） 

班级（班级号，班级名，班主任，班长） 

使用 GRANT 语句完成下列授权功能： 

```sql
#（1）授予用户 U1 对两个表的所有权限，并可给其他用户授权。 
GRANT ALL PRIVILEGES ON TABLE 学生,班级 TO U1 WITH GRANT OPTION;

#（2）授予用户 U2 对学生表具有查看权限，对家庭住址具有更新权限。 
GRANT SELECT,UPDATE(家庭住址) ON TABLE 学生 TO U2;

#（3）将对班级表查看权限授予所有用户。 
GRANT SELECT ON TABLE 班级 TO PUBLIC; 

#（4）将对学生表的查询，更新权限授予角色 R1。 
GRANT SELECT,UPDATE ON TABLE 学生 TO R1;

#（5）将角色 R1 授予用户 U1，并且 U1 可继续授权给其他角色。
GRANT R1 TO U1 WITH GRANT OPTION;
```



# 第 5 章 数据库完整性 作业 

<div align='center' ><font size='70'><b>第 5 章 数据库完整性 作业   </b></font></div>

**课后习题 4、5、6、7** 

**4.RDBMS 的完整性控制机制应具有哪三个方面的功能？**

 （1）定义功能：即提供定义完整性约束条件的机制。 

 （2）检查功能：即检查用户发出的操作请求是否违背了完整性约束条件。 

 （3）违约处理功能：如果发现用户的操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性。

**5.RDBMS 在实现参照完整性约束时需要考虑哪些方面？**

 RDBMS在实现参照完整性时需要考虑破坏参照完整性的各种情况，以及用户违约后的处理策略。

| 被参照表           |      | 参照表             | 违约处理                 |
| ------------------ | ---- | ------------------ | ------------------------ |
| 可能破坏参照完整性 | ←    | 插入元组           | 拒绝                     |
| 可能破坏参照完整性 | ←    | 修改外码值         | 拒绝                     |
| 删除元组           | →    | 可能破坏参照完整性 | 拒绝/级联删除/设置为空值 |
| 修改主码值         | →    | 可能破坏参照完整性 | 拒绝/级联删除/设置为空值 |



**6.假设有两个关系模式，分别定义两个模式的主码、参照完整性、 职工年龄不能超过 60 岁。（具体关系模式和题目要求请见课本第 173 页）**

```sql
CREATE TABLE 职工(
	职工号 CHAR(10) PRIMARY KEY,
    姓名 CHAR(10) NOT NULL,
    年龄 SMALLINT CHECK(年龄 < 60),
    职务 CHAR(10),
    工资 SMALLINT,
    部门号 CHAR(10)
);
CREATE TABLE 部门(
	部门号 CHAR(10) PRIMARY KEY,
    名称 CHAR(10) NOT NULL,
    经理名 CHAR(10),
    电话 CHAR(10)
);

ALTER TABLE 职工 ADD CONSTRAINT C_FOREIGNKEY1 FOREIGN KEY(部门号) REFERENCES 部门(部门号);
```



**7.RDBMS 中，当操作违反实体完整性、参照完整性和用户定义的完整性约束条件时，一般是如何分别如何处理的？**

对于违反实体完整性和用户定义的完整性的操作，一般都采用拒绝执行的方式进行处理；

对于参照完整性，需要考虑破坏参照完整性的各种情况，以及用户违约后的处理策略。

| 被参照表           |      | 参照表             | 违约处理                 |
| ------------------ | ---- | ------------------ | ------------------------ |
| 可能破坏参照完整性 | ←    | 插入元组           | 拒绝                     |
| 可能破坏参照完整性 | ←    | 修改外码值         | 拒绝                     |
| 删除元组           | →    | 可能破坏参照完整性 | 拒绝/级联删除/设置为空值 |
| 修改主码值         | →    | 可能破坏参照完整性 | 拒绝/级联删除/设置为空值 |







# **第 6 章 关系数据理论 作业** 

<div align='center' ><font size='70'><b>第 6 章 关系数据理论 作业   </b></font></div>

**课后习题 1、5、6、7，具体请详见课本 P.202-P.203** 

**1. 理解并给出下列术语的定义：** 

   **函数依赖、部分函数依赖、完全函数依赖、传递依赖、候选码、超码、主码、外码、全码（all-key）、INF、2NF、3NF、BCNF、多值依赖、4NF。** 

**（1）函数依赖：**设 R(U)是一个属性集 U 上的关系模式，X 和 Y 是 U 的子集。若对于 R(U)的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等， 而在 Y 上的属性值不等， 则称 “X 函数确定 Y” 或 “Y 函数依赖于 X”，记作 X→Y。 

**（2）完全函数依赖和部分函数依赖：**在关系模式 R(U)中，如果 X→Y，并且对于 X 的任何一个真子集 X’，都有 X’→ Y, 则称 Y 对 X 完全函数依赖，记作 X → Y。若 X→Y，但 Y 不完全函数依赖于 X， 则称 Y 对 X 部分函数依赖，记作 X → Y。 

**（3）传递依赖：**在关系模式 R(U)中，如果 X→Y，Y→Z，且 Y X，Y → X，则称 Z 对 X 传递函数依赖，记作 X →（传递） Z。 

**（4）候选码：**设 K 为关系模式 R<U,F>中的属性或属性组合。若 K → U，则 K 称为 R 的一个候选码（Candidate Key） 

**（5）主码：**若关系模式 R 有多个候选码，则选定其中的一个作 为主码（Primary key）。 

**（6）外码：**关系模式 R 中属性或属性组 X 并非 R 的码，但 X 是另一个关系模式的码，则称 X 是 R 的外部码（Foreign key），也称外码。

**（7）全码：**整个属性组 U 是码，称为全码（All-key）。

**（8）1NF：**若关系模式 R 的每一个分量是不可再分的数据项，则关系模式 R 属于第一范式(1NF)。 

**（9）2NF：**若关系模式 R∈1NF，并且每一个非主属性都完全函 数依赖于 R 的码，则 R∈2NF。 

**（10）3NF：**关系模式 R<U，F> 中若不存在这样的码 X、属性组 Y 及非主属性 Z（Z $\subset$ Y）, 使得 X→Y，Y → X，Y→Z，成立，则称R<U，F> ∈ 3NF。 

**（11）BCNF：**设关系模式 R<U，F>∈1NF，如果对于 R 的每个函数依赖 X→Y，若 Y 不属于 X，则 X 必含有候选码，那么 R∈BCNF。

**（12）多值依赖：**设有关系模式R(U)，U是属性全集，X，Y和Z是属性集U的子集，且Z=U-X-Y，如果对于R的任一关系，对于X的一个确定值，存在Y的一组值与之对应，且Y的这组值仅仅决定于X的值而与Z值无关,此时称Y多值依赖于X，或X多值决定Y，记作X→→Y。

**（13）4NF：**设关系模式*R*<*U*, *F*>∈1NF，如果对于*R*的每个非平凡多值依赖X→→Y (Y$\not\subset$X)，X都含有码，则R∈4NF



**5. 试举出三个多值依赖的实例。**

 (1) 关系模式 MSC(M,S,C)中,M 表示专业,S 表示学生,C 表示该专 业的必修课。假设每个专业有多个学生,有一组必修课。设同专业内所有学生选修的必修课相同,按照语义对于 M 的每一个值 M,S 有一个 完整的集合与之对应而不问 C 取何值,所以 M→→S。由于 C 与 S 的完 全对称性,必然有 M→→C 成立。 

 (2) 关系模式 ISA(I,S,A)中,I 表示学生兴趣小组,S 表示学生,A 表示兴趣小组的活动项目。假设每个兴趣小组有多个学生,有若干活 动项目。每个学生必须参加所在兴趣小组的所有活动项目,每个活动项目要求该兴趣小组的所有学生参加。 

 (3) 关系模式 RDP(R,D,P)中,R 表示医院的病房,D 表示责任医 务人员,P 表示病人。假设每个病房住有多个病人,有多个责任医务人员负责医治和护理该病房的所有病人。按照语义有 R→→D,R→→P 成立。

**6. 有关系模式 R(A,B,C,D,E),回答下面各个问题：** 

（1）若 A 是 R 的候选码，具有函数依赖 BC→DE,那么在什么条件下 R 是 BCNF? 

​		BC 是R的候选码

（2）如果存在函数依赖 A→B, BC→D,DE→A,列出 R 的所有码。 

​		ACE 、 BCE 、CDE

（3）如果存在函数依赖A→B, BC→D, DE→A, R属于3NF还是BCNF。

​		ABCDE 都是主属性，属于3NF

​		A、BC、DE不包含码，不属于BCNF 

**7.** **下面的结论哪些是正确的？哪些是错误的？对于错误的请给出一** **个反例说明之。** 

（1）任何一个二目关系是属于 3NF 的。 

（2）任何一个二目关系是属于 BCNF 的。 

（3）任何一个二目关系是属于 4NF 的。 

（4） 当且仅当函数依赖 A→B 在 R 上成立，关系 R(A,B,C)等于其投影 R1(A,B)和 R2(A,C)的连接。 

（5）若 R.A→R.B，R.B→R.C，则 R.A→R.C。 

（6）若 R.A→R.B，R.A→R.C，则 R.A→R.(B,C)。 

（7）若 R.B→R.A，R.C→R.A，则 R.(B,C)→R.A。

（8）若 R.(B,C)→R.A，则 R.B→R.A，R.C→R.A。



 (4)(8)错误 

 (4) 且仅当多值依赖 A->->B 在 R 上成立，关系 R(A,B,C)等于其投 

影 R1(A,B)和 R2(A,C)的连接

 (8) $R(Sno, Cno, Grade)  \quad (Sno, Cno)\rightarrow Grade \quad ,  Sno \not\rightarrow Grade ,  Cno \not\rightarrow Grade$



# **第7章 数据库设计 作业**

<div align='center' ><font size='70'><b>第7章 数据库设计 作业   </b></font></div>

**课后习题1、3、4、8、12**

**1.试述数据库设计过程。**

​	(1)需求分析 

​	(2)概念结构设计 

​	(3)逻辑结构设计 

​	(4)数据库物理设计 

​	(5)数据库实施 

​	(6)数据库运行和维护 

​	这是一个完整的实际数据库及其应用系统的设计过程。不仅包括设计数据库本身，还包括数据库的实施、数据库的运行和维护。设计一个完善的数据库应用系统往往是上述 6 个阶段的不断反复。 



**3.需求分析阶段的设计目标是什么? 调查的内容是什么?**

​	需求分析阶段的设计目标是通过详细调查现实世界要处理的对象(组织、部门、企业等),充分了解原系统(手工系统或计算机系统)工作概况,明确用户的各种需求, 然后在此基础上确定新系统的功能。 调查的内容是“数据”和“处理”,即获得用户对数据库的如下要求： 

 (1).信息要求。指用户需求从数据库中获得信息的内容与性质。有信息要求可以导出数据要求，即在数据库中需要存储哪些数据。

 (2).处理要求。指在用户要完成什么处理功能，对处理的响应时间有什么要求，处理方式是批处理还是联机处理。 

 (3).安全性与完整性要求。 



**4.数据字典的内容和作用是什么?**

  **数据字典的内容:** 包括数据项、数据结构、数据流、数据存储和处理过程 5 个部分。其中数据项是数据的最小组成单位,若干个数据项可以组成一个数据 

结构。数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。

  **数据字典的作用:** 数据字典是关于数据库中数据的描述,在需求分析阶段建立,是下一步进行概念设计的基础,并在数据库设计过程中不断修改、充实和完善。



**8.某工厂生产若干产品,每种产品由不同的零件组成,有的零件可用在不同的产品上。这些零件由不同的原材料制成,不同零件所用的材料可以相同。这些零件按所属的不同产品分别放在仓库中,原材料按照类别放在若干仓库中。请用 E-R 图画出此工厂产品、零件、材料、仓库的概念模型。**




**12.规范化理论对数据库设计有什么指导意义 ?**

​     规范化理论为数据库设计人员判断关系模式优劣提供了理论标准,可用以指导关系数据模型的优化，用来预测模式可能出现的问题，为设计人员提供了自动产生各种模式的算法工具,使数据库设计工作有了严格的理论基础。





# **第** **8** **章 数据库编程 作业** 

<div align='center' ><font size='70'><b>第8章 数据库编程 作业    </b></font></div>

**本章作业共包含** **2** **个，其中** **1** **为课本上的课后习题** 1。

**1. 使用嵌入式 SOL 对学生-课程数据库中的表完成下述功能∶**

（**1）查询某一门课程的信息。要查询的课程由用户在程序运行过程中指定，放在主变量中。**

```sqlite
EXEC SQL BEGIN DECLARE SECTION;
	char HCno(10);
	char HCnmae(10);
	char HCpno(10);
	char HCcredit(10);
	char givencno(10);
EXEC SQL END DECLARE SECTION;

EXEC SQL SELECT Cno,Cname,Cpno,HCcredit INTO:HCno,;HCnmae,;HCpno,:HCcredit FROM Course WHERE Cno = :givencno;
```



**（2）查询选修某一门课程的选课信息，要查询的课程号由用户在程序运行过程中指定，放在主变量中，然后根据用户的要求修改其中某些记录的成绩字段。**

```sqlite
EXEC SQL BEGIN DECLARE SECTION;
	char HCno(10);
	char HCnmae(10);
	char HCpno(10);
	char HCcredit(10);
	char givencno(10);
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE SCX CURSOR FOR SELECT Sno,Cno,Cname,Grade FROM SC WHERE Cno = :givencno; 
EXEC SQL OPEN SCX; 
for(;;) {
	EXEC SQL FETCH SCX INTO:HSno,:HCno,:HGrade;
	EXEC SQL UPDATE SC SET grade = :NEWGrade WHERE CURRENT OF SCX;
};
EXEC SQL CLOSE SCX;
```





**2.** **简述嵌入式** **SQL** **语句与主语言之间如何通信？**

(1)向主语言传递 SQL 语句的执行状态信息，使主语言能够据此信息控制程序流程， 主要用 SQL 通信区（SQL Communication Area， SQLCA）实现。 

(2)主语言向 SQL 语句提供参数，主要用主变量（host variable）实现。 

(3)将 SQL 语句查询数据库的结果交主语言处理，主要用主变量和游标（cursor）实现。



# **第 9 章 关系查询处理和查询优化 作业** 

<div align='center' ><font size='70'><b>第 9 章 关系查询处理和查询优化 作业     </b></font></div>

**课后习题 1、2、5、6、7** 

**1.试述査询优化在关系数据库系统中的重要性和可能性。** 

​	**(1)重要性：**查询优化在关系数据库系统中有着非常重要的地位。关系数据库系统和非过程化的SQL之所以能够取得巨大的成功，关键得益于查询优化技术的发展。它是影响关系数据库管理系统性能的关键因素。

​	**(2)可能性：**由于关系表达式的语义级别较高，使关系系统可以从关系表达式中分析查询语义，提供了执行查询优化的可能性。

**2.假设关系 R(A,B)和 S(B,C,D)情况如下:R 有 20 000 个元组,S 有 1 200 个元组，一个块能装 40 个 R 的元组，能装 30 个 S 的元组，估算下列操作需要多少次磁盘块读。**

​	①R 上没有索引 select * from R； 

​		20000 / 40  = 500 次

​	②R 中为 A 主码，其上有 3 层 B+树索引,select * from R where A= 10； 

​		3次索引 + 1次数据 = 4 次

​	③嵌套循环连接 R⋈ S；

​		需要先知道内存分配块数

​		1200/30 + 1200/30 /(分配块数) * 20000/40

​	④排序合并连接 R ⋈ S, 区分 R 与 S 在 B 属性上有序和无序两种情况。 

​		有序：20000 / 40 + 1200 /30 = 540次

​		无序：排序代价 $ 2\times B + 2\times B \times log_2B$

​		无序总代价：$540 + 2\times 500 + 2\times 500 \times log_2500 + 2\times 40+ 2\times 40\times log_240  $

​			

**5.对于题 4 中的数据库模式，存在如下的査询：** 

​	SELECT tname 

​	FROM teacher, department, work 

​	WHERE teacher.tno = work.tno AND department.dno=work.dno AND 

​	department.dname =’计算机系’ AND salary > 5000 

​	画出语法树以及用关系代数表示的语法树，并对关系代数语法树进行优化， 画出优化后的语法树。 

​	其中题 4 的数据库模式如下： 

​	Teacher（Tno，Tname，Tage，Tsex）；

​	Department（Dno，Dname，Tno）； 

​	Work（Tno，Dno，Year，Salary）

 	假设 Teacher 的 Tno 属性、Department 的 Dno 属性以及 Work 的 Year 属性上有 B+树索引。 


**6.试述关系数据库管理系统査询优化的一般准则。** 

​	(1)代数优化的一般准则 :

​		1.选择运算尽可能先做

​		2.把投影运算和选择运算同时进行

​		3.把投影同其前或后的双目运算结合起来，没有必要单独进行

​		4.把某些选择同在其前面要执行的笛卡尔乘积结合在一起，合成一个连接运算

​		5.找出公共子表达式

​	(2)物理优化的一般准则   

​		1.选择操作的启发式规则

​		2.连接操作的启发式规则

**7.试述关系数据库管理系统査询优化的一般步骤。**

​	(1) 把查询转换成某种内部表示，通常用的内部表示是语法树

​	(2) 把语法树转换成标准形式，再利用算法优化语法树

​	(3) 选择低层的存取路径

​	(4)生成查询计划，选择代价最小的



# **第 10 章 数据库恢复技术 作业** 

<div align='center' ><font size='70'><b>第 10 章 数据库恢复技术 作业      </b></font></div>

**课后习题 1、2、3、4、5** 

**1 试述事务的概念及事务的 4 个特性。恢复技术能保证事务的哪些特性？**

​	事务是指用户定义的数据库操作，其具有原子性（事务要么做完，要么不做）、一致性（事务要么处于做前、要么做后的状态）、隔离性（事务之间隔离不打扰）、持续性（事务对数据库中数据改变是永久的）。
​	恢复技术可以保证事务的原子性和一致性

**2.为什么事务非正常结束时会影响数据库数据的正确性？请举例说明之。**

​	事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致性状态。

​	例如事务转账时，需要先把转账方的钱扣了，再把钱加到收款方，如果钱扣完了事务就中断了，钱就消失了。



**3.登记日志文件时为什么必须先写日志文件，后写数据库?** 

​	如果先写了数据库修改，而且在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了。如果先写日志，但没有修改数据库，按日志文件恢复不过是多执行一次不必要的UNDO操作，并不会影响数据库的一致性。 

**4.考虑下图所示的日志记录：** 

| 日志 | 序号           |
| :--- | -------------- |
| 1    | T1：开始       |
| 2    | T1：写 A，A=10 |
| 3    | T2：开始       |
| 4    | T2：写 B，B=9  |
| 5    | T1：写 C，C=11 |
| 6    | T1：提交       |
| 7    | T2：写 C，C=13 |
| 8    | T3：开始       |
| 9    | T3：写 A，A=8  |
| 10   | T2：回滚       |
| 11   | T3：写 B，B=7  |
| 12   | T4：开始       |
| 13   | T3：提交       |
| 14   | T4：写 C，C=12 |

**(1) 如果系统故障发生在 14 之后，说明哪些事务需要重做，哪些事务需要回滚。** 

​	T1、T2、T3 重做 ， T4 回滚

**(2) 如果系统故障发生在 10 之后，说明哪些事务需要重做，哪些事务需要回滚。** 

​	T1、T2 重做 ， T3 回滚

**(3) 如果系统故障发生在 9 之后，说明哪些事务需要重做，哪些事务需要回滚。** 

​	T1 重做 ，T2、T3 回滚

**(4) 如果系统故院发生在 7 之后，说明哪些事务需要重做，哪些事务需要回滚。** 

​	T1 重做 ， T2 回滚



**5.考虑题 4 所示的日志记录，假设开始时 A、B、C 的值都是 0：** 

**（1）如果系统故障发生在 14 之后，写出系统恢复后 A、B、C 的值；** 

​			A = 8 , B = 7 , C = 11;

**（2）如果系统故障发生在 12 之后，写出系统恢复后 A、B、C 的值；** 

​			A = 10 , B = 0 , C = 11;

**（3）如果系统故障发生在 10 之后，写出系统恢复后 A、B、C 的值；** 

​			A = 10 , B = 0 , C = 11;

**（4）如果系统故障发生在 9 之后，写出系统恢复后 A、B、C 的值；** 

​			A = 10 , B = 0 , C = 11;

**（5）如果系统故障发生在 7 之后，写出系统恢复后 A、B、C 的值；** 

​			A = 10 , B = 0 , C = 11;

**（6）如果系统故障发生在 5 之后，写出系统恢复后 A、B、C 的值。**

​			A = 0 , B = 0 , C = 0;



# **第 11 章 并发控制 作业** 

<div align='center' ><font size='70'><b>第 11 章 并发控制 作业      </b></font></div>

**课后习题 1、2、3、4、8、9、10** 

**1.在数据库中为什么要并发控制？并发控制技术可以保证事务的哪些特征?** 

​	为了充分利用系统资源，发挥数据库共享资源的特点，应该允许多个事务并行地执行

​	事务并发会破坏事务的隔离性和一致性，需要并发控制技术保障



**2.并发操作可能会产生哪几类数据不一致？用什么方法嗯嗯避免各种不一致的情况？** 

​	数据不一致：

​	(1)丢失修改，两个事务T1和T2读入同一数据并修改,T2提交的结果破坏了(覆盖了)T1提交的结果,导致T1的修改被丢失。

​	(2)不可重复读 ，指事务T1读取数据后,事务T2提交执行更新操作,使T1无法再现前一次读取结果。

​	(3)读脏数据，指事务T1修改某一数据,并将其写回磁盘,事务T2读取同一数据后,T1由于某种原因被撤销,这时T1已修改过的数据恢复原值,T2读到的数据就与数据库中的数据不一致,则T2读到的数据就为“脏”数据,即不正确的数据。

​	封锁协议：

​	(1)一级封锁协议，事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。避免丢失修改。

​	(2)二级封锁协议，一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。避免丢失修改和读脏数据。

​	(3)三级封锁协议，一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。避免丢失修改和读脏数据和不可重复读。



**3.什么是封锁？基本的封锁类型有几种？试述他们的含义。** 

​	封锁是指事务对数据操作前，向系统请求封锁，释放锁前，其他事务不能更新数据。

​	有两种锁：排它锁（写锁，X锁）和共享锁（读锁，S锁。

​	排它锁：T对A加X锁，只允许T读取修改A，其他事务不能对A加锁、不能读取修改A，直到T释放锁。

​	共享锁：T对A加S锁，T可以读A不能修改A，其他事务只能对A加S锁不能加X锁，直到T释放锁。



**4.如何利用封锁机制保证数据的一致性？** 

​	在对数据进行读写操作之前首先对该数据库执行封锁操作，按照一定的封锁协议对并发操作进行控制，使得多个并发操作有序的执行，就可以避免丢失修改、不可重复读和读”脏“数据不一致性。



**8.什么样的并发调度是正确的调度？** 

​	当且仅当调度结果和串行化调度结果一致时才认为是正确调度。



**9.设 T1、T2、T3 是如下的三个事务, 设 A 的初值为 0：** 

T1: A:=A+2 

T2: A:=A*2 

T3: A:=A^2(A 的平方) 

**(1)若这三个事务允许并发执行，则有多少种可能的正确结果，请一一列举出来；** 

​		2 , 4 , 8 , 16

**(2)写出一个可串行化的调度,并给出执行结果；** 

​		可串行化的调度: r1(A)w1(A) r2(A)w2(A) r3(A)w3(A) 

​		结果为：16

**(3)写出一个非可串行化的调度，并给出执行结果；** 

​		非串行化的调度: r1(A)r2(A)r3(A)w1(A) w2(A) w3(A) 

​		结果为：0

**(4)若这三个事务都遵守两段锁协议，请给出一个不产生死锁的可串行化调度；** 

​		不产生死锁的可串行化的调度: r1(A)w1(A) r2(A)w2(A) r3(A)w3(A) 

**(5)若这三个事务都遵守两段锁协议，请给出一个产生死锁的调度。** 

​	产生死锁的调度的调度: r1(A)r2(A)r3(A)w1(A) w2(A) w3(A) 

**10.今有 3 个事务的一个调度 r3(B)r1(A)w3(B)r2(B)r2(A)w2(B)r1(B)w1(A),该调度是冲突可串行化的调度吗?为什么？**

​	是冲突可串行化的调度

​	r3(B)**r1(A)w3(B)**r2(B)r2(A)w2(B)r1(B)w1(A) 交换 r1(A)w3(B)得到

​	r3(B)w3(B)**r1(A)r2(B)**r2(A)w2(B)r1(B)w1(A) 交换 r1(A)r2(B)得到

​	r3(B)w3(B)r2(B)**r1(A)r2(A)**w2(B)r1(B)w1(A) 交换 r1(A)r2(A)得到

​	r3(B)w3(B)r2(B)r2(A)**r1(A)w2(B)**r1(B)w1(A) 交换 r1(A)w2(B)得到

​	r3(B)w3(B)r2(B)r2(A)w2(B)r1(A)r1(B)w1(A)  是串行的





