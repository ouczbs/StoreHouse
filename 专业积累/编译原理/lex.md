

# 环境搭建

## 安装 lex

- linux `yum install flex bison`

# 词法分析器



# Lex源程序

## 格式

[第一部分：定义段]

%%

第二部分：词法规则段

[%%

第三部分：辅助函数段]

方括号内容可省略

以%开头的符号和关键字，或者是词法规则段的各个规则一般顶着行首来写，前面没有空格。

注释由/*和*/括起，但是请注意，注释的行首需要有前导空白。

## 定义段

- c 语言定义

%{

 \#define LT 1

 int yylval;

%}

包含宏定义，常数定义，全局变量及外部变量定义，函数声明等

- 正规定义

letter	[A-Za-z]

digit		[0-9]

id		{letter}({letter}|{digit})*

正规定义是为了简化后面的词法规则而给部分正规式定义了名字

- 状态定义

%s COMMENT BAD

状态定义以%s开始，后跟所定义的状态的名字

## 词法规则段

while	   {return (WHILE);}

do		   {return (DO);}

{id}	     {yylval = installID (); return (ID);}

词法规则段列出的是词法分析器需要匹配的正规式，以及匹配该正规式后需要进行的相关动作。

每行都是一条规则，该规则的前一部分是正规式，需要顶行首写，后一部分是匹配该正规式后需要进行的动作，这个动作是用C语法来写的，被包裹在{}之内，被Lex翻译器翻译后会被直接拷贝进lex.yy.c。

也可以若干个正规式匹配同一条语义动作，此时正规式之间要用 | 分隔。

## 辅助函数段

辅助函数段用C语言语法来写，辅助函数一般是在词法规则段中用到的函数。这一部分一般会被直接拷贝到lex.yy.c中。

# 词法规则

## 正规式

### 元字符

元字符是lex语言中作特殊用途的一些字符，包括：* + ? | { } [ ] ( ) . ^ $ “ \ - / < >。

^表示补集：[^…]表示补集，即匹配除^之后所列字符以外的任何字符。

除^ - \以外，任何元字符在方括号内失去其特殊含义。如果要在方括号内表示负号-，则要将其至于方括号内的第一个字符位置或者最后一个字符位置，例如[-+0-9] [+0-9-]都匹配数字及+ - 号。

.  ^ $ /：

点运算符 . 匹配除换行之外的任何字符，一般可作为最后一条翻译规则。

^匹配行首字符。如：^begin匹配出现在行首的begin

$匹配行末字符。如：end$ 匹配出现在行末的end

R1/R2（R1和R2是正规式）表示超前搜索：若要匹配R1，则必须先看紧跟其后的超前搜索部分是否与R2匹配。

 如：DO/{alnum}*={alnum}*,表示如果想匹配DO，则必须先在DO后面找到形式为{alnum}*={alnum}*,的串，才能确定匹配DO。

### 正文字符

除元字符以外的其他字符，这些字符在正规式中可以被匹配。

元字符无法被匹配，如果元字符想要被匹配，则需要通过“转义”的方式，即用” ”包括住元字符，或在元字符前加\。例如”+”和\+都表示加号。C语言中的一些转义字符也可以出现在正规式中，例如\t \n \b等

## 词法状态

词法分析器在匹配正规式时，可以在不同状态（或环境）下进行。我们可以规定在不同的状态下有不同的匹配方式。

每个词法分析器都至少有一个状态，这个状态叫做初始状态，可以用INITIAL或0来表示，如果还需要使用其他状态，可以在定义段用%s 来定义。

使用状态时，可以用如下方式写词法规则：

<state1, state2> p0  {action0;}

<state1> p1     {action1;}



进入状态：BEGIN state;

## 匹配策略

- 按最长匹配原则确定被选中的单词

- 如果一个字符串能被若干正规式匹配，则先匹配排在前面的正规式。

# Lex程序

## 变量和宏

yyin和yyout：这是Lex中本身已定义的输入和输出文件指针。

这两个变量指明了lex生成的词法分析器从哪里获得输入和输出到哪里。默认：键盘输入，屏幕输出。

yytext和yyleng：这也是lex中已定义的变量，直接用就可以了。

yytext：指向当前识别的词法单元（词文）的指针

yyleng：当前词法单元的长度。

ECHO：Lex中预定义的宏，可以出现在动作中，相当于fprintf(yyout, “%s”,yytext)，即输出当前匹配的词法单元。

 ##  函数

yylex()：词法分析器驱动程序，用Lex翻译器生成的lex.yy.c内必然含有这个函数。返回值是记号

yywrap()：词法分析器遇到文件结尾时会调用yywrap()来决定下一步怎么做：

若yywrap()返回0，则继续扫描

若返回1，则返回报告文件结尾的0标记。

由于词法分析器总会调用yywrap，因此辅助函数中最好提供yywrap，如果不提供，则在用C编译器编译lex.yy.c时，需要链接相应的库，库中会给出标准的yywrap函数（标准函数返回1）。

## 使用规范

lex常常与语法分析器的生成工具yacc同时使用。

此时，一般来说，语法分析器每次都调用一次yylex()获取一个记号。

如果想自己写一个程序使用lex生成的词法分析器，则只需要在自己的程序中按需要调用yylex()函数即可。

请注意：yylex()调用结束后，输入缓冲区并不会被重置，而是仍然停留在刚才读到的地方。并且，词法分析器当前所处的状态（%s定义的那些状态）也不会改变。

# Lex流程

## 编译lex

用lex翻译器编译lex源程序命令

`flex filename.l`

## 生成程序

`gcc [-o outfile] lex.yy.c –lfl`

- -lfl 是链接flex的库函数的，库函数中可能包含类似yywrap一类的标准函数。
- -o outfile是可选编译选项，该选项可将编译生成的可执行程序命名为outfile，默认为a.exe

# 常见问题

## 词法规则段

匹配规则有顺序，后续词法不可被前向词法覆盖，覆盖则无法编译。

