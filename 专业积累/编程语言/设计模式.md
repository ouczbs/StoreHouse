title: 设计模式
--

# 模式理解


- 定义


    - 如何完整又简洁的描述你的代码结构


         - 类设计图


              - 继承关系以矩形表达


              - 交互关系连线表达


              -


    - 如何设计和定义类与类的关系


- 问关键词为什么


- 为什么需要这个模式，它解决了哪些问题


- 它还有哪些问题，如何解决这些问题


- 实际应用场景



类的分离和组合

- 分离
  - 父类
    - 提供统一的上层接口，实现多态
    - 工厂模式
  - 子类
    - 提供更多的表现形式，代码复用
  - 第三者
    - 职责分离，代码分离
    - 变换对象之间的依赖关系
      - 桥接
      - 适配器
      - 组合
      - 装饰
      - 
    - 组合工厂模式
- 组合
  - 类泛滥
  - 同类型的类可以合并

对象的创建和使用

- 创建
  - 原型模式
- 使用
  - 单例模式

# 23种设计模式


- 对象模式#对象


    - 原型模式


         - 当对象直接创建代价高时，可在内存层面复制克隆对象


         - 浅拷贝复制对象


    - 循环模式


         - 循环利用对象


    - 共享模式


         - 单例模式


              - 一个实例，全局访问


              - 预加载，浪费内存


              - 懒加载，线程不安全


         - 共享对象


- 结构模式  #类


    - 组合模式


         - 合并不同类型的类


    - 享元模式


         -


    - 代理模式


         - 静态代理


         - 动态代理


         - 简化调用者操作，创建逻辑剥离到工厂层中，统一管理底层实例。


- 行为模式 #代码


    - 责任链模式


         - 链上的每个节点都只需要了解到相邻节点即可组合成链条


    - 命令模式


         - 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的 操作。


    - 解释器模式


         - 组合模式的特殊形式 转化成树结构


    - 迭代器模式


         - 提供一种统一的方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。


    - 备忘录模式


         - 序列化与反序列化


         - 在不破坏封装的条件下，通过备忘录对象存储另外一个对象内部状态的快照，在将来合适的时候把这个对象还原到存储起来 的状态。


    - 观察者模式


         - 事件监听和响应


    - 状态模式


         - 继承和多态


    - 策略模式


         - 算法的多种实现和选择


    - 模板方法模式


         - 继承


    - 访问者模式


         - 发布订阅



--

# 游戏设计模式


-



--

# 六大原则


- 开闭原则


    - 能加不能改


- 单一职责


    - 类为基础单元功能单一


- 替换原则


    - 子类可任意替换基类


- 面向接口编程


- 接口隔离原则


- 黑盒原则


    - 对要调用的类知道的越少越好


-



--

# 类设计


- 可以把类中函数归类吗 （多文件 类似 go 语言）
